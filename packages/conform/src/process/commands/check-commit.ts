import * as fs from "node:fs";

import { loadConfigAsync } from "../../core/index.js";
import { type Config } from "../../core/index.js";

interface CheckCommitOptions {
  config?: string;
  quiet?: boolean;
}

/** Patterns that indicate auto-generated commits that should be skipped */
const AUTO_COMMIT_PATTERNS = [/^Merge /, /^Revert /, /^fixup! /, /^squash! /, /^amend! /];

type CommitsConfig = NonNullable<NonNullable<Config["process"]>["commits"]>;
type TicketsConfig = NonNullable<NonNullable<Config["process"]>["tickets"]>;

/** Check if a commit message is auto-generated */
function isAutoGeneratedCommit(message: string): boolean {
  return AUTO_COMMIT_PATTERNS.some((pattern) => pattern.test(message));
}

/** Build conventional commits pattern from configured types */
function buildConventionalPattern(types: string[], requireScope: boolean): string {
  const typePattern = types.join("|");
  // Use [^)]+ instead of .+ to avoid greedy matching through multiple parentheses
  const scopePattern = requireScope ? "\\([^)]+\\)" : "(\\([^)]+\\))?";
  return `^(${typePattern})${scopePattern}!?: .+`;
}

/** Check if text matches a regex pattern */
function matchesPattern(text: string, pattern: string): boolean {
  try {
    return new RegExp(pattern).test(text);
  } catch {
    return false;
  }
}

/** Read commit message from file */
function readCommitMessage(filePath: string): string | null {
  try {
    return fs.readFileSync(filePath, "utf-8").trim();
  } catch {
    return null;
  }
}

/** Log success message if not in quiet mode */
function logSuccess(quiet: boolean | undefined): void {
  if (!quiet) {
    console.warn("✓ Commit message is valid");
  }
}

/** Log skip message if not in quiet mode */
function logSkip(message: string, quiet: boolean | undefined): void {
  if (!quiet) {
    console.warn(`○ ${message}`);
  }
}

/** Log disabled message if not in quiet mode */
function logDisabled(quiet: boolean | undefined): void {
  if (!quiet) {
    console.warn("Commit message validation is not enabled in standards.toml");
  }
}

/** Log violations */
function logViolations(violations: string[]): void {
  console.error("✗ Invalid commit message:");
  for (const v of violations) {
    console.error(`  ${v}`);
  }
}

/** Validate ticket reference in commit message */
function validateTicketReference(
  commitMsg: string,
  ticketsConfig: TicketsConfig | undefined
): string[] {
  const ticketsEnabled = ticketsConfig?.enabled && ticketsConfig.require_in_commits;
  if (!ticketsEnabled || !ticketsConfig.pattern) {
    return [];
  }

  if (!matchesPattern(commitMsg, ticketsConfig.pattern)) {
    return [`Missing ticket reference matching: ${ticketsConfig.pattern}`];
  }
  return [];
}

/** Get pattern and description for commit format validation */
function getCommitPattern(commitsConfig: CommitsConfig): {
  pattern: string | undefined;
  description: string | undefined;
} {
  if (commitsConfig.pattern) {
    return { pattern: commitsConfig.pattern, description: commitsConfig.pattern };
  }

  const types = commitsConfig.types;
  if (types && types.length > 0) {
    const requireScope = commitsConfig.require_scope === true;
    const pattern = buildConventionalPattern(types, requireScope);
    const scopeHint = requireScope ? "(scope)" : "(scope)?";
    const description = `${types.join("|")}${scopeHint}: description`;
    return { pattern, description };
  }

  return { pattern: undefined, description: undefined };
}

/** Validate commit format using pattern */
function validateCommitFormat(subject: string, commitsConfig: CommitsConfig): string[] {
  const { pattern, description } = getCommitPattern(commitsConfig);

  if (!pattern || matchesPattern(subject, pattern)) {
    return [];
  }

  const violations = ["Commit message does not match required format"];
  if (description) {
    violations.push(`  Expected: ${description}`);
  }
  if (commitsConfig.types) {
    violations.push("  e.g., feat: add login page");
    violations.push("  e.g., fix(auth): resolve token expiry");
  }
  return violations;
}

/** Validate commit subject length */
function validateSubjectLength(subject: string, maxLength: number | undefined): string[] {
  if (maxLength && subject.length > maxLength) {
    return [`Subject line exceeds ${maxLength} characters (${subject.length})`];
  }
  return [];
}

/** Validate commit message against all configured rules */
function validateCommitMessage(
  commitMsg: string,
  ticketsConfig: TicketsConfig | undefined,
  commitsConfig: CommitsConfig | undefined
): string[] {
  const subject = commitMsg.split("\n")[0];
  const violations = validateTicketReference(commitMsg, ticketsConfig);

  if (commitsConfig?.enabled) {
    violations.push(...validateCommitFormat(subject, commitsConfig));
    violations.push(...validateSubjectLength(subject, commitsConfig.max_subject_length));
  }

  return violations;
}

/** Check if any validation is enabled */
function isValidationEnabled(
  ticketsConfig: TicketsConfig | undefined,
  commitsConfig: CommitsConfig | undefined
): boolean {
  const ticketsEnabled = Boolean(ticketsConfig?.enabled && ticketsConfig.require_in_commits);
  const commitsEnabled = Boolean(commitsConfig?.enabled);
  return ticketsEnabled || commitsEnabled;
}

/** Handle validation result and return exit code */
function handleValidationResult(violations: string[], quiet: boolean | undefined): number {
  if (violations.length === 0) {
    logSuccess(quiet);
    return 0;
  }
  logViolations(violations);
  return 1;
}

/**
 * Hook-friendly command to validate commit messages.
 * Designed for use in commit-msg hooks.
 *
 * @param commitMsgFile - Path to the file containing the commit message
 * @param options - Command options
 * @returns Exit code (0 = success, 1 = violation)
 */
export async function checkCommitCommand(
  commitMsgFile: string,
  options: CheckCommitOptions
): Promise<number> {
  const commitMsg = readCommitMessage(commitMsgFile);
  if (!commitMsg) {
    console.error(`✗ Could not read commit message file: ${commitMsgFile}`);
    return 1;
  }

  if (isAutoGeneratedCommit(commitMsg)) {
    logSkip("Skipping auto-generated commit message", options.quiet);
    return 0;
  }

  const { config } = await loadConfigAsync(options.config);
  const ticketsConfig = config.process?.tickets;
  const commitsConfig = config.process?.commits;

  if (!isValidationEnabled(ticketsConfig, commitsConfig)) {
    logDisabled(options.quiet);
    return 0;
  }

  const violations = validateCommitMessage(commitMsg, ticketsConfig, commitsConfig);
  return handleValidationResult(violations, options.quiet);
}
